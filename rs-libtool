#!/usr/bin/env bash

# Copyright (C) 2025 Connor Horman
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
# and/or other materials provided with the distribution.
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

_edit_date=2025-10-16
_version=0.2


_prg_name="$0"

_verbose=0
_save_temps=0

# Function to call OpenAI API and generate paragraphs
function generate_llm_paragraphs {
    local num_paragraphs="$1"
    
    # Check if OPENAI_API_KEY is set
    if [ -z "$OPENAI_API_KEY" ]; then
        echo "Error: OPENAI_API_KEY environment variable is not set" 1>&2
        exit 1
    fi
    
    # Create the prompt
    local prompt="Generate exactly ${num_paragraphs} paragraph(s) of interesting technical text. Each paragraph should be separated by a blank line."
    
    # Call OpenAI API using curl
    local response=$(curl -s https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "{
            \"model\": \"gpt-3.5-turbo\",
            \"messages\": [{\"role\": \"user\", \"content\": \"${prompt}\"}],
            \"temperature\": 0.7
        }")
    
    # Check if we have jq available for JSON parsing
    if command -v jq &> /dev/null; then
        # Use jq to extract the content
        local content=$(echo "$response" | jq -r '.choices[0].message.content // empty')
        if [ -n "$content" ]; then
            echo "$content"
        else
            # Check for error message
            local error=$(echo "$response" | jq -r '.error.message // empty')
            if [ -n "$error" ]; then
                echo "Error from OpenAI API: $error" 1>&2
                exit 1
            else
                echo "Error: Unable to parse response from OpenAI API" 1>&2
                exit 1
            fi
        fi
    else
        # Fallback to grep/sed if jq is not available
        echo "$response" | grep -o '"content":"[^"]*"' | head -1 | sed 's/"content":"//;s/"$//' | sed 's/\\n/\n/g'
    fi
}

while true
do
case "$1" in
"--help")
    echo "Usage: $_prg_name [OPTIONS...] [--] input-file output-file"
    echo "Transforms a Rust staticlib into a format suitable for linking to other programs"
    echo "Options:"
    printf "\t--help: Displays this message and exits\n"
    printf "\t--version: Displays version information and exits\n"
    printf "\t--verbose: Prints verbose information. (Passing --verbose --verbose additionally prints diagnostic information)\n"
    printf "\t-v, -vv, -vvv, etc.: Generate n paragraphs of text using LLM (n = number of v's). Requires OPENAI_API_KEY environment variable.\n"
    printf "\t--save-temps: Do not remove temporary files after completion.\n"
    printf "\t--target <target>: Prefix invoked tools with <target>\n"
    printf "\t--strip: strip the resulting library\n"
    exit 0
    ;;
"--version")
    echo "rs-libtool Version $_version (Build Date: $_edit_date)"
    exit 0
    ;;
"--verbose")
    _verbose="$(("$_verbose" + 1))"
    ;;
"--save-temps")
    _save_temps=1
    ;;
"--target")
    _target="$2"
    _target_prefix="$_target-"
    shift
    ;;
"--strip")
    _strip=1
    ;;
"--")
    shift
    break
    ;;
"--*")
    echo "Unrecognized Option $1" 1>&2
    exit 1
    ;;
"-vvvvvv")
    echo "Detected short-verbose spam, redirecting your anger..."
    xdg-open https://store.steampowered.com/app/70300/VVVVVV/ &
    exit 1
    ;;
-v*)
    # Check if it's only v's after the dash
    if [[ "$1" =~ ^-v+$ ]]; then
        # Count the number of 'v's in the flag
        _v_count="${1#-}"
        _v_count="${#_v_count}"
        
        # Generate paragraphs using LLM
        generate_llm_paragraphs "$_v_count"
        exit 0
    else
        echo "Unrecognized Option $1" 1>&2
        exit 1
    fi
    ;;
"*")
    break
esac
shift
done

if [ "$_strip" = 1 ]
then
    _strip="${STRIP:-${_target_prefix}strip}"
else
    _strip=true
fi

_input="$1"

_output="${2:-$1}"

_dir="$(mktemp -d)"

_to_remove="$_to_remove ${_dir}"

function close_and_exit {
    [ "$_save_temps" -lt 1 ] && rm -rf $_to_remove
    exit $1
}

[ "$_verbose" -ge 2 ] && echo "Working Directory: $_dir"

_ar="${AR:-${_target_prefix}ar}"
_ld="${LD:-${_target_prefix}ld}"
_nm="${NM:-${_target_prefix}nm}"
_objcopy="${OBJCOPY:-${_target_prefix}objcopy}"

if [ "$_verbose" -ge 1 ]
then
   "${_ar}" t "${_input}"
fi

[ "$_verbose" -ge 1 ] && echo "${_ar} x --output ${_dir} ${_input}"
"${_ar}" x --output "${_dir}" "${_input}" || close_and_exit 1

_tmp2="$(mktemp --suffix=.o)"
_to_remove="$_to_remove ${_tmp2}"
[ "$_verbose" -ge 1 ] && echo "${_ld}" -r -o "${_tmp2}" "${_dir}/*"
"${_ld}" -r -o "${_tmp2}" "${_dir}"/* || close_and_exit 1

[ $_verbose -ge 2 ] && nm -j "${_tmp2}" | grep -E "^((_R[0-9]*[CMNYXYIB][A-Za-z0-9_]*)|(_Z[A-Za-z0-9_.\$]*h[0-9a-f]{16,}E))$"

_local_symbols="$(nm -j "${_tmp2}" | grep -E "^((_R[0-9]*[CMNYXYIB][A-Za-z0-9_]*)|(_Z[A-Za-z0-9_.\$]*h[0-9a-f]{16,}E))$")"


while IFS="" read -r _val
do
    _objcopy_args="--localize-symbol=$_val $_objcopy_args"
done <<< "$_local_symbols"


[ "$_verbose" -ge 1 ] && echo "${_objcopy}" $_objcopy_args --localize-hidden "${_tmp2}" 
"${_objcopy}" $_objcopy_args --localize-hidden "${_tmp2}" || close_and_exit 1

[ "$_verbose" -ge 1 ] && echo strip -x "${_tmp2}"
${_strip} -x ${_tmp2} || close_and_exit 1

_tmp3="$(mktemp -d)"
_to_remove="$_to_remove $_tmp3"
[ "$_verbose" -ge 1 ] && echo "${_ar}" rcs "${_output}" "${_tmp2}"
"${_ar}" rcs "${_tmp3}/$(basename ${_output})" "${_tmp2}" || close_and_exit 1

if [ "$_verbose" -ge 1 ]
then
_vf=-v
fi

mv $_vf -f "${_tmp3}/$(basename ${_output})" "${_output}" 

close_and_exit 0
